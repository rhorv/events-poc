<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="edaJsonDeserializer" class="events.formatter.edaJsonSerDes.EdaJsonDeserializer">
    <constructor-arg ref="edaHardCodedJsonSchemaProvider"/>
  </bean>
  <bean id="edaJsonSerializer" class="events.formatter.edaJsonSerDes.EdaJsonSerializer">
    <constructor-arg ref="edaHardCodedJsonSchemaProvider"/>
  </bean>

  <bean id="edaDecoratedJsonSerializer" class="events.formatter.edaJsonSerDes.SerializedValidatorDecorator">
    <constructor-arg ref="edaJsonSerializer"/>
    <constructor-arg ref="edaHardCodedJsonSchemaProvider"/>
  </bean>

  <!-- For the avro deserialiser we are hard coding to use an avro file based specification for the schema provider
       showing that the producer and consumer can operate differently. In this case the consumer is using a
       specification it supports. A producer can move on to a new version without impacting a consumer as longs as
       the AVRO schema is BACKWARD compatible.
  -->
  <bean id="edaAvroSerialiser" class="events.formatter.edaAvroSerDes.EdaAvroSerialiser">
    <constructor-arg ref="schemaRegistry"/>
  </bean>
  <!-- For the avro deserialiser we are using the schema registry -->
  <bean id="edaAvroDeserialiser" class="events.formatter.edaAvroSerDes.EdaAvroDeserialiser">
    <constructor-arg ref="edaFileBasedAvroSchemaProvider"/>
  </bean>

  <bean id="edaMessageFamilyAwareDeserializer" class="events.formatter.MessageFamilyAwareDeserializer">
    <constructor-arg>
      <map>
        <entry key="#{T(events.formatter.EdaFormatterConstants).EDA_JSON_GENERIC}" value-ref="edaJsonDeserializer"/>
        <entry key="#{T(events.formatter.EdaFormatterConstants).EDA_AVRO_GENERIC}" value-ref="edaAvroDeserialiser"/>
      </map>
    </constructor-arg>
  </bean>

  <bean id="guavaDispatcher" class="events.dispatcher.guava.GuavaDispatcher">
  </bean>

  <bean id="rabbitConnectionFactory" class="com.rabbitmq.client.ConnectionFactory">
    <property name="username" value="admin"/>
    <property name="password" value="admin123"/>
    <property name="host" value="rabbitmq"/>
    <property name="port" value="5672"/>
    <property name="virtualHost" value="/"/>
  </bean>

  <bean id="kafkaConsumer" class="events.consumer.kafka.KafkaTopicConsumer">
    <constructor-arg ref="deserializer"/>
    <constructor-arg ref="dispatcher"/>
    <constructor-arg value="kafka:9092"/>
    <constructor-arg value="transactions"/>
  </bean>
  <bean id="rabbitConsumer" class="events.consumer.rabbitmq.RabbitMqConsumer">
    <constructor-arg ref="deserializer"/>
    <constructor-arg ref="dispatcher"/>
    <constructor-arg ref="rabbitConnectionFactory"/>
    <constructor-arg value="testqueue"/>
  </bean>

  <bean id="kafkaEventPublisher" class="events.publisher.kafka.KafkaTopicPublisher">
    <constructor-arg ref="edaAvroSerialiser"/>
    <constructor-arg value="kafka:9092"/>
    <constructor-arg value="transactions"/>
  </bean>
  <bean id="kafkaCommandPublisher" class="events.publisher.kafka.KafkaTopicPublisher">
    <constructor-arg ref="edaJsonSerializer"/>
    <constructor-arg value="kafka:9092"/>
    <constructor-arg value="transactions_handled"/>
  </bean>
  <bean id="rabbitEventPublisher" class="events.publisher.rabbitmq.RabbitMqPublisher">
    <constructor-arg ref="edaJsonSerializer"/>
    <constructor-arg ref="rabbitConnectionFactory"/>
    <constructor-arg value="events"/>
  </bean>
  <bean id="rabbitCommandPublisher" class="events.publisher.rabbitmq.RabbitMqPublisher">
    <constructor-arg ref="edaJsonSerializer"/>
    <constructor-arg ref="rabbitConnectionFactory"/>
    <constructor-arg value="commands"/>
  </bean>
  <bean id="splitRabbitPublisher" class="events.publisher.SplitPublisher">
    <constructor-arg>
      <map>
        <entry key="event" value-ref="rabbitEventPublisher"/>
        <entry key="command" value-ref="rabbitCommandPublisher"/>
      </map>
    </constructor-arg>
  </bean>
  <bean id="splitKafkaPublisher" class="events.publisher.SplitPublisher">
    <constructor-arg>
      <map>
        <entry key="event" value-ref="kafkaEventPublisher"/>
        <entry key="command" value-ref="kafkaCommandPublisher"/>
      </map>
    </constructor-arg>
  </bean>

  <bean id="transactionChargeHandler" class="application.handler.TransactionChargeHandler">
    <constructor-arg ref="messagePublisher"/>
  </bean>
  <bean id="refundCustomerHandler" class="application.handler.RefundCustomerHandler">
    <constructor-arg ref="messagePublisher"/>
  </bean>

  <!-- Use this for schemaProvider as an alias when using JSON and a hard code JSON schema provider -->
  <bean id="edaHardCodedJsonSchemaProvider" class="events.formatter.edaJsonSerDes.EdaJsonHardCodedSchemaProvider"/>
  <!-- Use this for schemaProvider as an alias when using AVRO and a hard code AVRO schema provider -->
  <bean id="edaFileBasedAvroSchemaProvider" class="events.formatter.edaAvroSerDes.EdaAvroFileBasedSchemaProvider"/>
  <!-- Use this for schemaProvider as an alias when using a schema registry -->
  <bean id="schemaRegistry" class="events.formatter.SchemaRegistry"/>

  <!--<alias name="schemaRegistry" alias="schemaProvider"/>-->
  <!--<alias name="edaHardCodedJsonSchemaProvider" alias="schemaProvider"/>-->
  <!--<alias name="edaFileBasedAvroSchemaProvider" alias="schemaProvider"/>-->

  <!--<alias name="edaAvroSerialiser" alias="serializer"/>-->
  <!--<alias name="edaJsonSerializer" alias="serializer"/>-->
  <alias name="decoratedJsonSerializer" alias="serializer"/>

  <!-- This deserialiser user the contents of the header to determine the appropriate deseriliser to use fo an eda event. -->
  <alias name="edaMessageFamilyAwareDeserializer" alias="deserializer"/>

  <alias name="guavaDispatcher" alias="dispatcher"/>

  <!-- Chane the following to switch between Kafka and RabbitMQ -->
  <alias name="splitRabbitPublisher" alias="messagePublisher"/>
  <alias name="rabbitConsumer" alias="messageConsumer"/>
  <!--<alias name="splitKafkaPublisher" alias="messagePublisher"/>-->
  <!--<alias name="kafkaConsumer" alias="messageConsumer"/>-->

</beans>